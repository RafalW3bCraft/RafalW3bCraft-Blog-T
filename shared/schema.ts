import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  index,
  serial,
  integer,
  boolean,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table - required for Replit Auth
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User storage table - enhanced for RBAC and OAuth
export const users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  username: varchar("username").unique(),
  bio: text("bio"),
  profileImageUrl: varchar("profile_image_url"),
  role: varchar("role").default("user"), // admin, user, visitor
  provider: varchar("provider"), // google, github, replit
  providerId: varchar("provider_id"),
  isActive: boolean("is_active").default(true),
  lastLogin: timestamp("last_login"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Blog posts table - enhanced with user authorship
export const blogPosts = pgTable("blog_posts", {
  id: serial("id").primaryKey(),
  title: varchar("title").notNull(),
  slug: varchar("slug").unique().notNull(),
  content: text("content").notNull(),
  excerpt: text("excerpt"),
  authorId: varchar("author_id").references(() => users.id),
  published: boolean("published").default(false),
  approved: boolean("approved").default(false), // admin approval
  isDraft: boolean("is_draft").default(true),
  isAutoGenerated: boolean("is_auto_generated").default(false), // AI-generated from GitHub
  tags: text("tags").array().default([]),
  views: integer("views").default(0),
  githubRepo: varchar("github_repo"), // source repo for auto-generated posts
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// User drafts table - personal workspace functionality
export const userDrafts = pgTable("user_drafts", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  title: varchar("title").notNull(),
  content: text("content").notNull(),
  excerpt: text("excerpt"),
  tags: text("tags").array().default([]),
  readingTime: integer("reading_time").default(1),
  isShared: boolean("is_shared").default(false),
  shareId: varchar("share_id").unique(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// User bookmarks table - bookmark tracking
export const userBookmarks = pgTable("user_bookmarks", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  postId: integer("post_id").references(() => blogPosts.id).notNull(),
  readingProgress: integer("reading_progress").default(0), // percentage 0-100
  bookmarkedAt: timestamp("bookmarked_at").defaultNow(),
});

// Contact messages table
export const contactMessages = pgTable("contact_messages", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  email: varchar("email").notNull(),
  subject: varchar("subject").notNull(),
  message: text("message").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

// Audio play logs to prevent re-triggering falcon sounds
export const audioPlayLogs = pgTable("audio_play_logs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  audioType: varchar("audio_type").notNull(), // falcon-rising, falcon-cry, etc
  playedAt: timestamp("played_at").defaultNow(),
  sessionId: varchar("session_id"),
});

// System audit logs for Falcon's Mandate security monitoring
export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  action: varchar("action").notNull(), // login, admin_access, blog_edit, etc
  resource: varchar("resource"), // blog_post, user, system
  resourceId: varchar("resource_id"), // specific resource identifier
  details: jsonb("details"), // action metadata
  ipAddress: varchar("ip_address"),
  userAgent: varchar("user_agent"),
  sessionId: varchar("session_id"),
  method: varchar("method"), // GET, POST, PUT, DELETE
  endpoint: varchar("endpoint"), // API endpoint accessed
  statusCode: integer("status_code"), // HTTP response code
  duration: integer("duration"), // request duration in ms
  severity: varchar("severity").default("info"), // info, warning, critical, error
  category: varchar("category").default("general"), // auth, data, security, system, api
  riskScore: integer("risk_score").default(0), // 0-100 security risk assessment
  createdAt: timestamp("created_at").defaultNow(),
});

// Failed login attempts for security monitoring
export const failedLoginAttempts = pgTable("failed_login_attempts", {
  id: serial("id").primaryKey(),
  email: varchar("email"),
  ipAddress: varchar("ip_address").notNull(),
  userAgent: varchar("user_agent"),
  attemptedAt: timestamp("attempted_at").defaultNow(),
  provider: varchar("provider"), // google, github
});

// System health monitoring
export const systemHealth = pgTable("system_health", {
  id: serial("id").primaryKey(),
  metricType: varchar("metric_type").notNull(), // performance, security, uptime
  metricName: varchar("metric_name").notNull(),
  value: jsonb("value"),
  status: varchar("status").default("healthy"), // healthy, warning, critical
  checkedAt: timestamp("checked_at").defaultNow(),
});

// Analytics table for tracking page views and stats
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  path: varchar("path").notNull(),
  userAgent: text("user_agent"),
  ipAddress: varchar("ip_address"),
  timestamp: timestamp("timestamp").defaultNow(),
});

// GitHub projects table (enhanced for real repository data)
export const githubProjects = pgTable("github_projects", {
  id: serial("id").primaryKey(),
  githubId: integer("github_id").unique(), // GitHub's actual repository ID
  name: varchar("name").notNull().unique(),
  fullName: varchar("full_name"), // owner/repo format
  description: text("description"),
  language: varchar("language"),
  stars: integer("stars").default(0),
  forks: integer("forks").default(0),
  size: integer("size").default(0), // in KB from GitHub API
  url: varchar("url").notNull(),
  homepage: varchar("homepage"),
  topics: text("topics").array().default([]),
  isPrivate: boolean("is_private").default(false),
  createdAt: timestamp("created_at"),
  updatedAt: timestamp("updated_at"),
  lastUpdated: timestamp("last_updated").defaultNow(),
  lastSyncedAt: timestamp("last_synced_at").defaultNow(),
});

// Real-time messaging system
export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: varchar("sender_id").references(() => users.id).notNull(),
  recipientId: varchar("recipient_id").references(() => users.id), // null for admin messages
  content: text("content").notNull(),
  originalContent: text("original_content"), // before AI moderation/rewriting
  isModerated: boolean("is_moderated").default(false),
  moderationAction: varchar("moderation_action"), // filtered, rewritten, flagged
  roomId: varchar("room_id"), // for group chats
  messageType: varchar("message_type").default("text"), // text, image, file
  isRead: boolean("is_read").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Blog comments system with moderation and nested comments
export const comments = pgTable("comments", {
  id: serial("id").primaryKey(),
  blogPostId: integer("blog_post_id").references(() => blogPosts.id).notNull(),
  authorId: varchar("author_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  originalContent: text("original_content"), // before AI moderation
  isModerated: boolean("is_moderated").default(false),
  moderationAction: varchar("moderation_action"),
  approved: boolean("approved").default(true), // Auto-approve unless flagged
  parentCommentId: integer("parent_comment_id"), // Self-reference for nested comments (constraint added below)
  depth: integer("depth").default(0), // Comment nesting level (0 = root, 1 = reply, etc.)
  isDeleted: boolean("is_deleted").default(false), // Soft delete for comment threads
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Comment and blog post likes system
export const likes = pgTable("likes", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  blogPostId: integer("blog_post_id").references(() => blogPosts.id), // For blog post likes
  commentId: integer("comment_id").references(() => comments.id), // For comment likes
  likeType: varchar("like_type").notNull().default("like"), // like, dislike, love, etc.
  createdAt: timestamp("created_at").defaultNow(),
});

// GitHub repository integration for auto-blog generation
export const githubRepoIntegration = pgTable("github_repo_integration", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  repoName: varchar("repo_name").notNull(),
  repoUrl: varchar("repo_url").notNull(),
  repoDescription: text("repo_description"),
  isPrivate: boolean("is_private").default(false),
  defaultBranch: varchar("default_branch").default("main"),
  language: varchar("language"),
  stars: integer("stars").default(0),
  forks: integer("forks").default(0),
  lastCommitSha: varchar("last_commit_sha"),
  lastCommitDate: timestamp("last_commit_date"),
  isEnabled: boolean("is_enabled").default(true), // Whether to auto-generate blog posts
  autoBlogGenerated: boolean("auto_blog_generated").default(false), // Has blog been generated
  blogPostId: integer("blog_post_id").references(() => blogPosts.id), // Generated blog post reference
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Admin direct messages system
export const adminMessages = pgTable("admin_messages", {
  id: serial("id").primaryKey(),
  adminId: varchar("admin_id").references(() => users.id).notNull(),
  recipientId: varchar("recipient_id").references(() => users.id).notNull(),
  subject: varchar("subject").notNull(),
  content: text("content").notNull(),
  messageType: varchar("message_type").default("direct"), // direct, notification, warning
  priority: varchar("priority").default("normal"), // low, normal, high, urgent
  isRead: boolean("is_read").default(false),
  readAt: timestamp("read_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// User GitHub tokens table - secure encrypted storage for user GitHub personal access tokens
export const userGithubTokens = pgTable("user_github_tokens", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull().unique(),
  encryptedToken: text("encrypted_token").notNull(), // AES-256 encrypted GitHub token
  tokenScope: text("token_scope"), // Scopes granted by the token
  isValid: boolean("is_valid").default(true),
  lastValidated: timestamp("last_validated"),
  expiresAt: timestamp("expires_at"), // Token expiration if applicable
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Moderation logs and AI analysis
export const moderationLogs = pgTable("moderation_logs", {
  id: serial("id").primaryKey(),
  contentType: varchar("content_type").notNull(), // message, comment, blog_post
  contentId: varchar("content_id").notNull(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  originalText: text("original_text").notNull(),
  moderatedText: text("moderated_text"),
  action: varchar("action").notNull(), // approved, filtered, rewritten, flagged
  reason: text("reason"), // AI analysis reason
  sentimentScore: integer("sentiment_score"), // -100 to 100
  toxicityLevel: varchar("toxicity_level"), // low, medium, high
  aiProvider: varchar("ai_provider"), // openai, local_llm, etc
  reviewedBy: varchar("reviewed_by").references(() => users.id), // admin review
  createdAt: timestamp("created_at").defaultNow(),
});

// User notifications system
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  type: varchar("type").notNull(), // message, comment_reply, blog_approved, etc
  title: varchar("title").notNull(),
  message: text("message").notNull(),
  relatedId: integer("related_id"), // reference to related content
  relatedType: varchar("related_type"), // blog_post, message, comment
  isRead: boolean("is_read").default(false),
  actionUrl: varchar("action_url"), // deep link for notification action
  createdAt: timestamp("created_at").defaultNow(),
});

// Type exports
export type User = typeof users.$inferSelect;
export type UpsertUser = typeof users.$inferInsert;

// Insert schemas with omitted auto-generated fields
export const insertBlogPostSchema = createInsertSchema(blogPosts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertContactMessageSchema = createInsertSchema(contactMessages).omit({
  id: true,
  createdAt: true,
});

export const insertAnalyticsSchema = createInsertSchema(analytics).omit({
  id: true,
  timestamp: true,
});

export const insertMessageSchema = createInsertSchema(messages).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCommentSchema = createInsertSchema(comments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertModerationLogSchema = createInsertSchema(moderationLogs).omit({
  id: true,
  createdAt: true,
});

export const insertNotificationSchema = createInsertSchema(notifications).omit({
  id: true,
  createdAt: true,
});

// Enhanced commenting and likes schemas
export const insertLikeSchema = createInsertSchema(likes).omit({
  id: true,
  createdAt: true,
});

export const insertGithubRepoIntegrationSchema = createInsertSchema(githubRepoIntegration).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertAdminMessageSchema = createInsertSchema(adminMessages).omit({
  id: true,
  createdAt: true,
});

// User drafts and bookmarks schemas
export const insertUserDraftSchema = createInsertSchema(userDrafts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertUserBookmarkSchema = createInsertSchema(userBookmarks).omit({
  id: true,
  bookmarkedAt: true,
});

// Audio play logs schema
export const insertAudioPlayLogSchema = createInsertSchema(audioPlayLogs);

// Audit logs schema  
export const insertAuditLogSchema = createInsertSchema(auditLogs);

// Failed login attempts schema
export const insertFailedLoginAttemptSchema = createInsertSchema(failedLoginAttempts);

// System health schema
export const insertSystemHealthSchema = createInsertSchema(systemHealth);

// Type definitions for all tables
export type InsertBlogPost = z.infer<typeof insertBlogPostSchema>;
export type BlogPost = typeof blogPosts.$inferSelect;
export type InsertUserDraft = z.infer<typeof insertUserDraftSchema>;
export type UserDraft = typeof userDrafts.$inferSelect;
export type InsertUserBookmark = z.infer<typeof insertUserBookmarkSchema>;
export type UserBookmark = typeof userBookmarks.$inferSelect;
export type InsertContactMessage = z.infer<typeof insertContactMessageSchema>;
export type ContactMessage = typeof contactMessages.$inferSelect;
export type InsertAnalytics = z.infer<typeof insertAnalyticsSchema>;
export type Analytics = typeof analytics.$inferSelect;
export type GithubProject = typeof githubProjects.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;
export type InsertComment = z.infer<typeof insertCommentSchema>;
export type Comment = typeof comments.$inferSelect;
export type InsertModerationLog = z.infer<typeof insertModerationLogSchema>;
export type ModerationLog = typeof moderationLogs.$inferSelect;
export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;
export type InsertAudioPlayLog = z.infer<typeof insertAudioPlayLogSchema>;
export type AudioPlayLog = typeof audioPlayLogs.$inferSelect;
export type InsertAuditLog = z.infer<typeof insertAuditLogSchema>;
export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertFailedLoginAttempt = z.infer<typeof insertFailedLoginAttemptSchema>;
export type FailedLoginAttempt = typeof failedLoginAttempts.$inferSelect;
export type InsertSystemHealth = z.infer<typeof insertSystemHealthSchema>;
export type SystemHealth = typeof systemHealth.$inferSelect;

// Enhanced feature type definitions
export type Like = typeof likes.$inferSelect;
export type InsertLike = z.infer<typeof insertLikeSchema>;
export type GithubRepoIntegration = typeof githubRepoIntegration.$inferSelect;
export type InsertGithubRepoIntegration = z.infer<typeof insertGithubRepoIntegrationSchema>;
export type AdminMessage = typeof adminMessages.$inferSelect;
export type InsertAdminMessage = z.infer<typeof insertAdminMessageSchema>;
export type UserGithubToken = typeof userGithubTokens.$inferSelect;
export type InsertUserGithubToken = typeof userGithubTokens.$inferInsert;

// User site data table for personal site builder
export const userSiteData = pgTable('user_site_data', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 255 }),
  title: varchar('title', { length: 500 }),
  bio: text('bio'),
  email: varchar('email', { length: 255 }),
  github: varchar('github', { length: 255 }),
  website: varchar('website', { length: 500 }),
  skills: text('skills'), // JSON array as text
  theme: varchar('theme', { length: 50 }).default('cybersecurity'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const insertUserSiteDataSchema = createInsertSchema(userSiteData);
export type UserSiteData = typeof userSiteData.$inferSelect;
export type InsertUserSiteData = z.infer<typeof insertUserSiteDataSchema>;
