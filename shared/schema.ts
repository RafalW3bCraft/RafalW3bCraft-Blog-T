import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  index,
  serial,
  integer,
  boolean,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";


export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);


export const users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  username: varchar("username").unique(),
  bio: text("bio"),
  profileImageUrl: varchar("profile_image_url"),
  role: varchar("role").default("user"), 
  provider: varchar("provider"), 
  providerId: varchar("provider_id"),
  isActive: boolean("is_active").default(true),
  lastLogin: timestamp("last_login"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const blogPosts = pgTable("blog_posts", {
  id: serial("id").primaryKey(),
  title: varchar("title").notNull(),
  slug: varchar("slug").unique().notNull(),
  content: text("content").notNull(),
  excerpt: text("excerpt"),
  authorId: varchar("author_id").references(() => users.id),
  published: boolean("published").default(false),
  approved: boolean("approved").default(false), 
  isDraft: boolean("is_draft").default(true),
  isAutoGenerated: boolean("is_auto_generated").default(false), 
  tags: text("tags").array().default([]),
  views: integer("views").default(0),
  githubRepo: varchar("github_repo"), 
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const userDrafts = pgTable("user_drafts", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  title: varchar("title").notNull(),
  content: text("content").notNull(),
  excerpt: text("excerpt"),
  tags: text("tags").array().default([]),
  readingTime: integer("reading_time").default(1),
  isShared: boolean("is_shared").default(false),
  shareId: varchar("share_id").unique(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const userBookmarks = pgTable("user_bookmarks", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  postId: integer("post_id").references(() => blogPosts.id).notNull(),
  readingProgress: integer("reading_progress").default(0), 
  bookmarkedAt: timestamp("bookmarked_at").defaultNow(),
});


export const contactMessages = pgTable("contact_messages", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  email: varchar("email").notNull(),
  subject: varchar("subject").notNull(),
  message: text("message").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});


export const audioPlayLogs = pgTable("audio_play_logs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  audioType: varchar("audio_type").notNull(), 
  playedAt: timestamp("played_at").defaultNow(),
  sessionId: varchar("session_id"),
});


export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  action: varchar("action").notNull(), 
  resource: varchar("resource"), 
  resourceId: varchar("resource_id"), 
  details: jsonb("details"), 
  ipAddress: varchar("ip_address"),
  userAgent: varchar("user_agent"),
  sessionId: varchar("session_id"),
  method: varchar("method"), 
  endpoint: varchar("endpoint"), 
  statusCode: integer("status_code"), 
  duration: integer("duration"), 
  severity: varchar("severity").default("info"), 
  category: varchar("category").default("general"), 
  riskScore: integer("risk_score").default(0), 
  createdAt: timestamp("created_at").defaultNow(),
});


export const failedLoginAttempts = pgTable("failed_login_attempts", {
  id: serial("id").primaryKey(),
  email: varchar("email"),
  ipAddress: varchar("ip_address").notNull(),
  userAgent: varchar("user_agent"),
  attemptedAt: timestamp("attempted_at").defaultNow(),
  provider: varchar("provider"), 
});


export const systemHealth = pgTable("system_health", {
  id: serial("id").primaryKey(),
  metricType: varchar("metric_type").notNull(), 
  metricName: varchar("metric_name").notNull(),
  value: jsonb("value"),
  status: varchar("status").default("healthy"), 
  checkedAt: timestamp("checked_at").defaultNow(),
});


export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  path: varchar("path").notNull(),
  userAgent: text("user_agent"),
  ipAddress: varchar("ip_address"),
  timestamp: timestamp("timestamp").defaultNow(),
});


export const githubProjects = pgTable("github_projects", {
  id: serial("id").primaryKey(),
  githubId: integer("github_id").unique(), 
  name: varchar("name").notNull().unique(),
  fullName: varchar("full_name"), 
  description: text("description"),
  language: varchar("language"),
  stars: integer("stars").default(0),
  forks: integer("forks").default(0),
  size: integer("size").default(0), 
  url: varchar("url").notNull(),
  homepage: varchar("homepage"),
  topics: text("topics").array().default([]),
  isPrivate: boolean("is_private").default(false),
  createdAt: timestamp("created_at"),
  updatedAt: timestamp("updated_at"),
  lastUpdated: timestamp("last_updated").defaultNow(),
  lastSyncedAt: timestamp("last_synced_at").defaultNow(),
});


export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: varchar("sender_id").references(() => users.id).notNull(),
  recipientId: varchar("recipient_id").references(() => users.id), 
  content: text("content").notNull(),
  originalContent: text("original_content"), 
  isModerated: boolean("is_moderated").default(false),
  moderationAction: varchar("moderation_action"), 
  roomId: varchar("room_id"), 
  messageType: varchar("message_type").default("text"), 
  isRead: boolean("is_read").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const comments = pgTable("comments", {
  id: serial("id").primaryKey(),
  blogPostId: integer("blog_post_id").references(() => blogPosts.id).notNull(),
  authorId: varchar("author_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  originalContent: text("original_content"), 
  isModerated: boolean("is_moderated").default(false),
  moderationAction: varchar("moderation_action"),
  approved: boolean("approved").default(true), 
  parentCommentId: integer("parent_comment_id"), 
  depth: integer("depth").default(0), 
  isDeleted: boolean("is_deleted").default(false), 
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const likes = pgTable("likes", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  blogPostId: integer("blog_post_id").references(() => blogPosts.id), 
  commentId: integer("comment_id").references(() => comments.id), 
  likeType: varchar("like_type").notNull().default("like"), 
  createdAt: timestamp("created_at").defaultNow(),
});


export const githubRepoIntegration = pgTable("github_repo_integration", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  repoName: varchar("repo_name").notNull(),
  repoUrl: varchar("repo_url").notNull(),
  repoDescription: text("repo_description"),
  isPrivate: boolean("is_private").default(false),
  defaultBranch: varchar("default_branch").default("main"),
  language: varchar("language"),
  stars: integer("stars").default(0),
  forks: integer("forks").default(0),
  lastCommitSha: varchar("last_commit_sha"),
  lastCommitDate: timestamp("last_commit_date"),
  isEnabled: boolean("is_enabled").default(true), 
  autoBlogGenerated: boolean("auto_blog_generated").default(false), 
  blogPostId: integer("blog_post_id").references(() => blogPosts.id), 
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const adminMessages = pgTable("admin_messages", {
  id: serial("id").primaryKey(),
  adminId: varchar("admin_id").references(() => users.id).notNull(),
  recipientId: varchar("recipient_id").references(() => users.id).notNull(),
  subject: varchar("subject").notNull(),
  content: text("content").notNull(),
  messageType: varchar("message_type").default("direct"), 
  priority: varchar("priority").default("normal"), 
  isRead: boolean("is_read").default(false),
  readAt: timestamp("read_at"),
  createdAt: timestamp("created_at").defaultNow(),
});


export const userGithubTokens = pgTable("user_github_tokens", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull().unique(),
  encryptedToken: text("encrypted_token").notNull(), 
  tokenScope: text("token_scope"), 
  isValid: boolean("is_valid").default(true),
  lastValidated: timestamp("last_validated"),
  expiresAt: timestamp("expires_at"), 
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});


export const moderationLogs = pgTable("moderation_logs", {
  id: serial("id").primaryKey(),
  contentType: varchar("content_type").notNull(), 
  contentId: varchar("content_id").notNull(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  originalText: text("original_text").notNull(),
  moderatedText: text("moderated_text"),
  action: varchar("action").notNull(), 
  reason: text("reason"), 
  sentimentScore: integer("sentiment_score"), 
  toxicityLevel: varchar("toxicity_level"), 
  aiProvider: varchar("ai_provider"), 
  reviewedBy: varchar("reviewed_by").references(() => users.id), 
  createdAt: timestamp("created_at").defaultNow(),
});


export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  type: varchar("type").notNull(), 
  title: varchar("title").notNull(),
  message: text("message").notNull(),
  relatedId: integer("related_id"), 
  relatedType: varchar("related_type"), 
  isRead: boolean("is_read").default(false),
  actionUrl: varchar("action_url"), 
  createdAt: timestamp("created_at").defaultNow(),
});


export type User = typeof users.$inferSelect;
export type UpsertUser = typeof users.$inferInsert;


export const insertBlogPostSchema = createInsertSchema(blogPosts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertContactMessageSchema = createInsertSchema(contactMessages).omit({
  id: true,
  createdAt: true,
});

export const insertAnalyticsSchema = createInsertSchema(analytics).omit({
  id: true,
  timestamp: true,
});

export const insertMessageSchema = createInsertSchema(messages).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCommentSchema = createInsertSchema(comments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertModerationLogSchema = createInsertSchema(moderationLogs).omit({
  id: true,
  createdAt: true,
});

export const insertNotificationSchema = createInsertSchema(notifications).omit({
  id: true,
  createdAt: true,
});


export const insertLikeSchema = createInsertSchema(likes).omit({
  id: true,
  createdAt: true,
});

export const insertGithubRepoIntegrationSchema = createInsertSchema(githubRepoIntegration).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertAdminMessageSchema = createInsertSchema(adminMessages).omit({
  id: true,
  createdAt: true,
});


export const insertUserDraftSchema = createInsertSchema(userDrafts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertUserBookmarkSchema = createInsertSchema(userBookmarks).omit({
  id: true,
  bookmarkedAt: true,
});


export const insertAudioPlayLogSchema = createInsertSchema(audioPlayLogs);


export const insertAuditLogSchema = createInsertSchema(auditLogs);


export const insertFailedLoginAttemptSchema = createInsertSchema(failedLoginAttempts);


export const insertSystemHealthSchema = createInsertSchema(systemHealth);


export type InsertBlogPost = z.infer<typeof insertBlogPostSchema>;
export type BlogPost = typeof blogPosts.$inferSelect;
export type InsertUserDraft = z.infer<typeof insertUserDraftSchema>;
export type UserDraft = typeof userDrafts.$inferSelect;
export type InsertUserBookmark = z.infer<typeof insertUserBookmarkSchema>;
export type UserBookmark = typeof userBookmarks.$inferSelect;
export type InsertContactMessage = z.infer<typeof insertContactMessageSchema>;
export type ContactMessage = typeof contactMessages.$inferSelect;
export type InsertAnalytics = z.infer<typeof insertAnalyticsSchema>;
export type Analytics = typeof analytics.$inferSelect;
export type GithubProject = typeof githubProjects.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;
export type InsertComment = z.infer<typeof insertCommentSchema>;
export type Comment = typeof comments.$inferSelect;
export type InsertModerationLog = z.infer<typeof insertModerationLogSchema>;
export type ModerationLog = typeof moderationLogs.$inferSelect;
export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;
export type InsertAudioPlayLog = z.infer<typeof insertAudioPlayLogSchema>;
export type AudioPlayLog = typeof audioPlayLogs.$inferSelect;
export type InsertAuditLog = z.infer<typeof insertAuditLogSchema>;
export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertFailedLoginAttempt = z.infer<typeof insertFailedLoginAttemptSchema>;
export type FailedLoginAttempt = typeof failedLoginAttempts.$inferSelect;
export type InsertSystemHealth = z.infer<typeof insertSystemHealthSchema>;
export type SystemHealth = typeof systemHealth.$inferSelect;


export type Like = typeof likes.$inferSelect;
export type InsertLike = z.infer<typeof insertLikeSchema>;
export type GithubRepoIntegration = typeof githubRepoIntegration.$inferSelect;
export type InsertGithubRepoIntegration = z.infer<typeof insertGithubRepoIntegrationSchema>;
export type AdminMessage = typeof adminMessages.$inferSelect;
export type InsertAdminMessage = z.infer<typeof insertAdminMessageSchema>;
export type UserGithubToken = typeof userGithubTokens.$inferSelect;
export type InsertUserGithubToken = typeof userGithubTokens.$inferInsert;


export const userSiteData = pgTable('user_site_data', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 255 }),
  title: varchar('title', { length: 500 }),
  bio: text('bio'),
  email: varchar('email', { length: 255 }),
  github: varchar('github', { length: 255 }),
  website: varchar('website', { length: 500 }),
  skills: text('skills'), 
  theme: varchar('theme', { length: 50 }).default('cybersecurity'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const insertUserSiteDataSchema = createInsertSchema(userSiteData);
export type UserSiteData = typeof userSiteData.$inferSelect;
export type InsertUserSiteData = z.infer<typeof insertUserSiteDataSchema>;


export const userSecuritySettings = pgTable('user_security_settings', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id').references(() => users.id).notNull().unique(),
  twoFactorEnabled: boolean('two_factor_enabled').default(false),
  sessionTimeout: integer('session_timeout').default(1440), 
  loginNotifications: boolean('login_notifications').default(true),
  suspiciousActivityAlerts: boolean('suspicious_activity_alerts').default(true),
  ipWhitelistEnabled: boolean('ip_whitelist_enabled').default(false),
  deviceTrackingEnabled: boolean('device_tracking_enabled').default(true),
  ipWhitelist: text('ip_whitelist').array().default([]),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});


export const userNotificationSettings = pgTable('user_notification_settings', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id').references(() => users.id).notNull().unique(),
  emailNotifications: boolean('email_notifications').default(true),
  blogCommentNotifications: boolean('blog_comment_notifications').default(true),
  blogLikeNotifications: boolean('blog_like_notifications').default(true),
  securityAlerts: boolean('security_alerts').default(true),
  githubSyncNotifications: boolean('github_sync_notifications').default(true),
  systemUpdates: boolean('system_updates').default(true),
  marketingEmails: boolean('marketing_emails').default(false),
  weeklyDigest: boolean('weekly_digest').default(false),
  emailFrequency: varchar('email_frequency').default('immediate'), 
  quietHoursEnabled: boolean('quiet_hours_enabled').default(false),
  quietHoursStart: varchar('quiet_hours_start').default('22:00'),
  quietHoursEnd: varchar('quiet_hours_end').default('08:00'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});


export const userApiTokens = pgTable('user_api_tokens', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id').references(() => users.id).notNull(),
  tokenHash: varchar('token_hash').notNull(), 
  tokenPrefix: varchar('token_prefix').notNull(), 
  name: varchar('name'), 
  expiresAt: timestamp('expires_at'),
  lastUsedAt: timestamp('last_used_at'),
  isActive: boolean('is_active').default(true),
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertUserSecuritySettingsSchema = createInsertSchema(userSecuritySettings);
export const insertUserNotificationSettingsSchema = createInsertSchema(userNotificationSettings);
export const insertUserApiTokenSchema = createInsertSchema(userApiTokens);

export type UserSecuritySettings = typeof userSecuritySettings.$inferSelect;
export type InsertUserSecuritySettings = z.infer<typeof insertUserSecuritySettingsSchema>;
export type UserNotificationSettings = typeof userNotificationSettings.$inferSelect;
export type InsertUserNotificationSettings = z.infer<typeof insertUserNotificationSettingsSchema>;
export type UserApiToken = typeof userApiTokens.$inferSelect;
export type InsertUserApiToken = z.infer<typeof insertUserApiTokenSchema>;
